# 📚 SLASH 21

##  [🔗](https://www.youtube.com/watch?v=DHPeeEvDbdo) Micro-frontend React, 점진적으로 도입하기

> 주제: 토스팀에서 Django MVC 프로젝트가 Micro-frontend React  프로젝트로 탈바꿈하는 이야기

### 1. Django MVC 프로젝트에 점진적으로 React를 도입한 방법

* 빠르게 프로젝트를 도입하기 위해 `create-react-app`을 사용함 (추후 설정을 다시 바꿔야했기 때문에 좋지 않은 선택이었음)
* `webpack-bundle-tracker`와 `django-webpack-loader` 를 도입함.

### 2. 마이크로 프론트엔드 아키텍처를 도입한 이유와 후기

* 도입 이유: 높은 의존성과 긴 빌드 시간
  1. 기존의 거대한 소스 코드를 독립적인 패키지들로 분리(유지보수가 이루어지는 단위로 분리. 인프라 패키지, 라이브러리 패키지, 서비스 패키지)
  2. yarn2 Workspace Plugin을 통해 구현중

* 장점: 소스 코드부터 빌드 설정까지 완벽한 격리. 의존성 지옥 탈출.  빌드 속도 최적화

### 3. 프론트엔드 빌드 시간을 효과적으로  단축한 비법

* 빌드 시간을 줄이는 가장 좋은 방법? 빌드 자체를 하지 않는 것
* 소스 코드가 바뀐 패키지만 빌드하고 나머지는 기존 빌드 결과물을 재사용
* 소스 코드가 바뀌었는지는 어떻게 알 수 있을까? Git의 commit ID를 활용. 이전 커밋의 해시와 현재 커밋의 해시를 비교함.
* 기존  빌드 결과물을 Git에 압축하여 저장해두었음
* (Yarn2의 Zero-Installs이 동작하는 방식과 비슷함)
* 빌드 속도가 최대 15배까지 빨라지는 효과를 얻을 수 있었음

### 마이크로 프론트 아키텍처란?

* 마이크로 프론트엔드는 마이크로  서비스처럼 전체 화면을 작동할 수 있는 단위로 나누어 개발한 후 서로 조립하는 방식이다.
* 장점)
  * 작고, 응집력 있고 유지보수성을 가지는 코드베이스를 가질 수 있다.
  * 분리배포가 용이하고, 자율적인 팀 조직운영이 수월해진다.
  * 프론트엔드 개발을 점진적 업그레이드 또는 재작성이 수월해진다.
* 단점)
  * 배포 번들 사이즈가 커질 수 있다.
  * 서로 간의 개발 환경 차이로 복잡도가 올라간다.
  * 운영이 복잡해진다.

## [🔗](https://www.youtube.com/watch?v=FvRtoViujGg&t=9s) 프론트 엔드 웹 서비스에서 우아하게 비동기 처리하기

* 비동기 프로그래밍 > 순서가 보장되지 않은 상황
* async-await 코드의 장점: '성공하는 경우'만 다루고, '실패하는 경우'는 catch절에서 분리해 처리한다. '실패하는 경우'에 대한 처리를 외부에 위임할 수 있다.
* 좋은 코드의 특징)
  * 성공, 실패의 경우를 분리해 처리할 수 있다.
  * 비즈니스 로직을 한눈에 파악할 수 있다.
* 어려운 코드의 특징)
  * 실패, 성공의 경우가 서로 섞여 처리된다.
  * 비즈니스 로직을 파악하기 어렵다.
* 프론트엔드 웹 서비스에서 지금까지의 비동기 처리들은..?
  * 비동기를 처리하는 부분을 정의한다.
  * 컴포넌트에서 로딩과 에러 처리를 동시에 수행한다.
* React의 비동기 처리는 어렵다.
  * 성공하는 경우에만 집중해 컴포넌트를 구성하기 어렵다
  * 2개 이상의 비동기 로직이 개입할 때, 비즈니스 로직을 파악하기 점점 어려워진다.
* **React Suspense for Data Fetching**
  * 아직은 실험버전에서만 사용가능하다.
  * 목표)
    * 성공한 경우에만 집중할 수 있는
    * 로딩 상태와 에러 상태가 분리된
    * 동기와 거의  같게 사용할 수 있는
  * 에러 상태와 로딩 상태는 어떻게 분리되는가?
    * 컴포넌트를 '쓰는 쪽'에서 로딩 처리와 에러 처리를 한다.
    * 로딩 상태는 가장 가까운 'Suspense'의 'Fallback'으로 그려진다.
    * 에러 상태는 가장 가까운 'ErrorBoundary'가 componentDidCatch()로 처리한다.
  * React Suspense를 사용하면 로딩과 에러 처리를 바깥으로 위임하며 비동기 작업을 동기와 똑같이 처리할 수 있다.
* 웹 서비스의 코드 복잡도를 낮춘 방법
  * Hooks
    * 실제 상태 관리, 메모이제이션 등의 작업은 컴포넌트를 감싸는 React 프레임워크가 수행
  * Suspense
    * 실제 로딩 상태, 에러 상태 처리는 컴포넌트를 감싸는 부모 컴포넌트가 수행
  * try-catch
    * 실제 에러 처리는 컴포넌트를 감싸는 부모 함수가 수행
* 대수적 효과: 어떤 코드 조각을 감싸는 맥락으로 책임을 분리하는 방식
* 기타 공유하고 싶은 키워드: React Concurrent Mode, useTransition, useDeferredValue